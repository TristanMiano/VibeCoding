#!/usr/bin/env python3
"""
generate_project_overview.py

Usage examples:

  # full overview, no skipping
  python generate_project_overview.py

  # short mode: only signatures/docstrings in .py files
  python generate_project_overview.py --short

  # skip everything under data/ and build/, but re-include data/important/
  python generate_project_overview.py \
      --exclude data/** build/** \
      --include data/important/**

  # you can mix --short with --exclude/--include freely
"""

import os
import sys
import ast
import fnmatch
import argparse
from pathlib import Path

# A naive list of known standard library modules we skip from "requirements".
STANDARD_LIBS = {
    "abc", "argparse", "ast", "asyncio", "base64", "binascii", "bisect", "builtins", "calendar",
    "collections", "concurrent", "contextlib", "copy", "csv", "ctypes", "datetime", "decimal",
    "difflib", "dis", "distutils", "email", "enum", "errno", "faulthandler", "filecmp", "fileinput",
    "fnmatch", "fractions", "functools", "gc", "getopt", "getpass", "gettext", "glob", "gzip", "hashlib",
    "heapq", "hmac", "http", "imaplib", "imp", "importlib", "inspect", "io", "ipaddress", "itertools",
    "json", "logging", "lzma", "math", "multiprocessing", "numbers", "operator", "os", "pathlib",
    "pickle", "platform", "plistlib", "pprint", "queue", "random", "re", "runpy", "sched", "secrets",
    "select", "shlex", "shell", "shutil", "signal", "site", "smtp", "smtplib", "socket", "socketserver",
    "sqlite3", "ssl", "stat", "statistics", "string", "struct", "subprocess", "sys", "tempfile", "termios",
    "textwrap", "threading", "time", "timeit", "tkinter", "traceback", "types", "typing", "unittest",
    "urllib", "uuid", "venv", "warnings", "wave", "weakref", "webbrowser", "xml", "xmlrpc", "zipfile", "zipimport"
}

PROMPT_TEXT = """PROMPT FOR AI MODEL:

You are about to read a detailed overview of a software project. Please read 
everything in the following text and act as a helpful software engineering assistant. This overview itself is generated by one of the files which will be described below.

At the end of the overview, there will be a list of next steps for implementation. Please tailor your response for these steps. Generally, if more than one step is listed, focus on the first one only in your first response. The user will probably request the subsequent steps later.

If you can't find any next steps for the project listed at the bottom of the file, please do your best to look for mistakes, errors, discrepancies, or ways to clean up and refine the project, and decide yourself what should be considered high priority, and include that in your first response.

--------------------------------------------------------------------------------
"""

def is_text_file(file_path: Path) -> bool:
    text_extensions = {
        '.txt', '.md', '.rst', '.py', '.java', '.js', '.ts', '.cpp', '.c',
        '.cs', '.html', '.css', '.xml', '.yaml', '.yml', '.sh', '.bat',
        '.go', '.rb', '.php', '.swift', '.kt', '.scala', '.pl', '.sql'
    }
    return file_path.suffix.lower() in text_extensions

def get_file_type(file_path: Path) -> str:
    return file_path.suffix.lower() if file_path.suffix else 'No Extension'

def extract_functions_and_docstrings(file_content: str) -> str:
    try:
        tree = ast.parse(file_content)
    except SyntaxError:
        return ""
    lines = []
    module_doc = ast.get_docstring(tree)
    if module_doc:
        lines.append(f'Module Docstring:\n"""{module_doc}"""\n')
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            lines.append(f"def {node.name}(...):")
            doc = ast.get_docstring(node)
            if doc:
                lines.append(f'    """{doc}"""')
            lines.append("")
        elif isinstance(node, ast.ClassDef):
            lines.append(f"class {node.name}(...):")
            doc = ast.get_docstring(node)
            if doc:
                lines.append(f'    """{doc}"""')
            for sub in node.body:
                if isinstance(sub, ast.FunctionDef):
                    lines.append(f"    def {sub.name}(...):")
                    mdoc = ast.get_docstring(sub)
                    if mdoc:
                        lines.append(f'        """{mdoc}"""')
            lines.append("")
    return "\n".join(lines)

def parse_imports_from_python(file_content: str) -> set[str]:
    try:
        tree = ast.parse(file_content)
    except SyntaxError:
        return set()
    mods = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                mods.add(alias.name.split('.')[0])
        elif isinstance(node, ast.ImportFrom) and node.module:
            mods.add(node.module.split('.')[0])
    return mods

def is_standard_library(module_name: str) -> bool:
    return module_name in STANDARD_LIBS

def is_excluded(
    rel_path: str,
    exclude_patterns: list[str],
    include_patterns: list[str]
) -> bool:
    # Include always wins
    for pat in include_patterns:
        if fnmatch.fnmatch(rel_path, pat):
            return False
    # Then exclude
    for pat in exclude_patterns:
        if fnmatch.fnmatch(rel_path, pat):
            return True
    return False

def traverse_directory(
    root_path: Path,
    short_version: bool = False,
    exclude_patterns: list[str] = None,
    include_patterns: list[str] = None
):
    exclude_patterns = exclude_patterns or []
    include_patterns = include_patterns or []

    directory_structure = []
    relevant_contents = []
    third_party_libraries = set()

    readme_exts = {'.md', '.markdown', '.txt'}
    code_exts = {
        '.py', '.java', '.js', '.ts', '.cpp', '.c', '.cs', '.html', '.css',
        '.xml', '.yaml', '.yml', '.sh', '.bat', '.go', '.rb',
        '.php', '.swift', '.kt', '.scala', '.pl', '.sql'
    }
    doc_exts = readme_exts | {'.rst'}

    for dirpath, dirnames, filenames in os.walk(root_path):
        # skip hidden dirs
        dirnames[:] = [d for d in dirnames if not d.startswith('.')]
        rel_dir = Path(dirpath).relative_to(root_path).as_posix() or "."
        # skip if entire dir excluded
        if is_excluded(rel_dir, exclude_patterns, include_patterns):
            continue

        directory_structure.append(f"Directory: {rel_dir}")

        # prune dirnames by exclude/include
        dirnames[:] = [
            d for d in dirnames
            if not is_excluded(f"{rel_dir}/{d}", exclude_patterns, include_patterns)
        ]

        for fn in filenames:
            if fn.startswith('.'):
                continue
            rel_file = fn if rel_dir == "." else f"{rel_dir}/{fn}"
            if is_excluded(rel_file, exclude_patterns, include_patterns):
                continue

            p = Path(dirpath) / fn
            ft = get_file_type(p)
            directory_structure.append(f"  File: {fn} | Type: {ft}")

            if is_text_file(p) and (p.suffix in readme_exts or p.suffix in code_exts or p.suffix in doc_exts):
                try:
                    content = p.read_text(encoding='utf-8')
                    if p.suffix == '.py':
                        imports = parse_imports_from_python(content)
                        for lib in imports:
                            if not is_standard_library(lib):
                                third_party_libraries.add(lib)

                    should_shorten = short_version and p.suffix == '.py'
                    if should_shorten:
                        snippet = extract_functions_and_docstrings(content)
                        header = f"\n=== Functions & Docstrings in {rel_file} ===\n"
                        relevant_contents.append(header + snippet)
                    else:
                        header = f"\n=== Content of {rel_file} ===\n"
                        relevant_contents.append(header + content)

                except Exception as e:
                    print(f"Warning: could not read {p}: {e}", file=sys.stderr)

    return directory_structure, relevant_contents, third_party_libraries

def main():
    parser = argparse.ArgumentParser(description="Generate a project overview.")
    parser.add_argument(
        "--short", action="store_true", default=False,
        help="Only include function signatures & docstrings for .py files."
    )
    parser.add_argument(
        "-e", "--exclude", nargs="*", default=[],
        help="Glob patterns of files/dirs to skip entirely."
    )
    parser.add_argument(
        "-i", "--include", nargs="*", default=[],
        help="Glob patterns to force-include (overrides exclude)."
    )
    args = parser.parse_args()

    root = Path(__file__).parent.resolve()
    print(f"Traversing directory: {root}")

    dirs, contents, libs = traverse_directory(
        root_path=root,
        short_version=args.short,
        exclude_patterns=args.exclude,
        include_patterns=args.include
    )

    # write overview
    overview = root / "project_overview.txt"
    with overview.open('w', encoding='utf-8') as f:
        f.write(PROMPT_TEXT)
        f.write("\n=== Directory Structure ===\n")
        f.write("\n".join(dirs))
        f.write("\n\n=== Consolidated Documentation ===\n")
        f.write("\n".join(contents))
    print(f"Written overview to {overview}")

    # write requirements
    req = root / "requirements_autogenerated.txt"
    with req.open('w', encoding='utf-8') as f:
        for lib in sorted(libs):
            f.write(lib.lower() + "\n")
    print(f"Written requirements to {req}")

if __name__ == "__main__":
    main()
